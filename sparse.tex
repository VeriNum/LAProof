\section{An accurate and correct C program}
\label{sec:sparse}

In the previous section we described a functional
model of the floating-point matrix-vector product (\lstinline{MVF}) and introduced
the formal
proof in Coq of its accuracy. In this section, we describe a C program implementing
compressed sparse
row (CSR) matrix-vector multiplication, and a formal proof in Coq that this program
exactly implements the floating-point functional model.  We then compose the accuracy and correctness proofs in Coq to demonstrate that the C program is correct and accurate.

\subsection{Sparse matrix-vector product }
\label{sparse}
Compressed sparse row (CSR) is a standard data structure for
sparse matrices that enables fast matrix-vector
multiplications\cite[\S4.3.1]{barret94:templates}. The CSR
format stores the elements of a sparse $m\times n$ matrix $A$
using three one-dimensional arrays: a floating-point array
\lstinline{val} that stores the nonzero elements of $A$, an
integer array \lstinline{col$\_$ind} that stores the column
indices of the elements in \lstinline{col$\_$ind}, and an integer
array \lstinline{row$\_$ptr} that stores the locations in the array
\lstinline{col$\_$ind} that start a row in $A$. 
Figure \ref{fig:CSR} shows an example
(from~\cite{barret94:templates}, adjusted for 0-based array indexing).
\begin{figure}
\[
\left(
\begin{array}{r@{~~}r@{~~}r@{~~}r@{~~}r@{~~}r}
  10 & 0 & 0 & 0 & -2 & 0 \\
  3 & 9 & 0 & 0 & 0 & 3 \\
  0 & 7 & 8 & 7 & 0 & 0 \\
  3 & 0 & 8 & 7 & 5 & 0 \\
  0 & 8 & 0 & 9 & 9 & 13 \\
  0 & 4 & 0 & 0 & 2 & -1 \\
\end{array}
\right)
\]
\[
%\genfrac{}{}{0pt}{2} if using amsmath, otherwise:
\begin{array}{c}
\begin{array}{|r|@{\hspace{1pt}}r@{\hspace{2pt}}|@{\hspace{1pt}}r@{\hspace{2pt}}|@{\hspace{1pt}}r@{\hspace{2pt}}|@{\hspace{1pt}}r@{\hspace{2pt}}|@{\hspace{1pt}}r@{\hspace{2pt}}|@{\hspace{1pt}}r@{\hspace{2pt}}|@{\hspace{1pt}}r@{\hspace{2pt}}|@{\hspace{1pt}}r@{\hspace{2pt}}|@{\hspace{1pt}}r@{\hspace{2pt}}|@{\hspace{1pt}}r@{\hspace{2pt}}|@{\hspace{1pt}}r@{\hspace{2pt}}|@{\hspace{1pt}}r@{\hspace{2pt}}|@{\hspace{1pt}}r@{\hspace{2pt}}|@{}l@{}}
  \cline{1-14}
\mathtt{val} & 10 & -2 & ~3 & ~9 & ~3 & ~7 & ~8 & ~7 & ~3 \cdots9 & 13 & ~4 & ~2 &
-1 \\
  \cline{1-14}
\mathtt{col\_ind} & 0 & 4 & 0 & 1 & 5 & 1 & 2 & 3 & 0 \cdots 4 &5 & 1 & 4 & 5 \\
  \cline{1-14}
  \multicolumn{1}{l}{} &
  \multicolumn{2}{@{}l}{\mbox{\scriptsize 0}} &
  \multicolumn{3}{@{}l}{\mbox{\scriptsize{2}}} &
  \multicolumn{3}{@{}l}{\mbox{\scriptsize{5}}} &
  \multicolumn{2}{@{}l}{\mbox{\scriptsize{8}}} &
  \multicolumn{3}{@{}l}{\mbox{\scriptsize{16}}} &
  \multicolumn{1}{@{}l}{\mbox{\scriptsize{19}}} \\[6pt]
\end{array}\\
\begin{array}{|r|r|r|r|r|r|r|r|}
  \hline
  \mathtt{row\_ptr} & 0 & 2 & 5 & 8 & 12 & 16 & 19 \\
  \hline
\end{array}
\end{array}
\]
\caption{An example of the three arrays (\lstinline{val},
\lstinline{col\_ind}, \lstinline{row\_ptr}) used to store a matrix
compressed sparse row (CSR) format.}
\label{fig:CSR}
\end{figure}

\begin{lstlisting}[language=C,float,captionpos=b,caption= A CSR struct in C.,label=lst:csrstruct]
struct csr_matrix {
     double *val; 
     unsigned *col_ind, *row_ptr, rows, cols; 
};
\end{lstlisting}

Our C implementation utilizes the CSR data structure given in Listing \ref{lst:csrstruct}.  The C function implementing sparse matrix-vector multiplication is shown in Listing~\ref{csr-mv-mult}.
We use zero-based indexing for arrays and matrices.
The $i$th element of \lstinline{row_ptr} points into an offset
within \lstinline{val} and within \lstinline{col_ind} where
the $i$th row is represented.
For $\mathtt{row\_ptr}(i) \le h < \mathtt{row\_ptr}(i+1)$,
$\mathtt{col\_ind}(h)=j$, we have $A_{ij}=\mathtt{val}(h)$;
and elsewhere $A_{ij}=0$.

\begin{lstlisting}[language=C,float,captionpos=b,caption=CSR matrix-vector multiplication
in C.,label=csr-mv-mult]
void csr$\_$mv$\_$multiply (struct csr$\_$matrix *m,  
	double *v,  double *p) {
  unsigned i, rows = m $\rightarrow$ rows;
  double *val = m $\rightarrow$ val;
  unsigned *col$\_$ind = m $\rightarrow$ col$\_$ind;
  unsigned *row$\_$ptr = m $\rightarrow$ row$\_$ptr;
  unsigned next=row$\_$ptr[0];
  for (i = 0; i < rows; i++) {
    double s = 0.0;
    unsigned h = next;
    next = row4$\_$ptr[i+1];
    for (h = 0; h < next; h++) {
      double x = val[h];
      unsigned j = col$\_$ind[h];
      double y = v[j];
      s = fma(x,y,s); 
    }
    p[i]=s; 
} }
\end{lstlisting}

\subsection{Verifying the C program}
We use VST \cite{vst-floyd} to specify and verify the C
implementation of sparse matrix-vector multiplication.  VST is a higher-order impredicative logic for the C language embedded in the Coq proof assistant.  As a variant of Hoare logics,  judgements in VST take the familiar form of the Hoare triple $ \{Pre\} \ c \ \{Post\}$, where the preconditions $Pre$ and postcondition $Post$ are assertions on program states.  
These assertions (preconditions, postconditions, loop invariants, etc.)
are written as \lstinline{PROP(P) LOCAL(L) SEP(R)} where \lstinline{P} is a sequence of Coq terms of type \lstinline{Prop},  \lstinline{L} characterizes the values
of local and global variables, and \lstinline{R} is a spatial assertion describing the contents of the
heap. In function preconditions, in place of the \lstinline{LOCAL()} part we write \lstinline{PARAMS()};
and in function postconditions, we write \lstinline{RETURN()}.

The VST specification of the CSR function (\lstinline{csr_mv_spec}) is shown in Listing~\ref{funspec}.  The specification and its corresponding proof 
show that the CSR function calculates the same floating-point computation as the dense matrix-multiply functional model, \emph{except} that where $A_{ij}=0$,  the dense algorithm computes $A_{ij}\cdot x_i+s$ where the sparse algorithm just uses $s$. This is a notable difference in floating-point arithmetic, where it is not always the case that
$0\cdot y+s=s$,  for instance when $y$ is $\infty$ or
NaN.  Even when $y$ and $s$ are finite values in the format, it is
not always true that $y\cdot 0+s$ is the same floating-point
value as $s$ because of signed zeros.  Finally, even when all elements of the matrix $A$ and vector $x$ are 
finite, we cannot assume that the intermediate results $s$ are
finite as the computatation may introduce overflow.  

Thus, when specifying the correctness of matrix-vector multiplication we must tread carefully:
we reason modulo equivalence relations.
We define \lstinline{feq $x$ $y$} to mean that either
both $x$ and $y$ are finite and equal (with $+0=-0$),
or neither is finite (both are infinities or NaNs).
Our function will have a precondition that
$A$ and $x$ are all finite, and postcondition that
the computed result is \lstinline{feq} to the
result that a dense matrix multiply algorithm would compute. For such reasoning we use Coq's
\lstinline{Parametric} \lstinline{Morphism} system for reasoning over partial
equivalence relations using rewrite rules \cite{sozeau09:rewriting}.

\begin{lstlisting}[float,label=funspec,captionpos=b,caption=Function specification
for CSR matrix-vector multiply]
Definition csr_mv_spec :=
DECLARE _csr_mv_multiply
WITH $\pi_1$: share, $\pi_2$: share, $\pi_3$: share,
      m: val, $A$: matrix Tdouble, v: val, 
      $x$: vector Tdouble, p: val
PRE [ tptr t_csr, tptr tdouble, tptr tdouble ]
  PROP(readable_share $\pi_1$; readable_share $\pi_2$; 
         writable_share $\pi_3$;
         matrix_cols $A$ (Zlength $x$);
         matrix_rows $A$ < Int.max_unsigned;
         Zlength $x$ < Int.max_unsigned;
         Forall finite $x$;
         Forall (Forall finite) $A$)
  PARAMS(m; v; p)
  SEP (csr_rep $\pi_1$ $A$ m;
       data_at $\pi_2$ (tarray tdouble (Zlength $x$)) 
				(map Vfloat $x$) v; 
       data_at_ $\pi_3$ (tarray tdouble (matrix_rows $A$)) p)
POST [ tvoid ]
 EX $y$: vector Tdouble,
  PROP(Forall2 feq $y$ (MVF $A$ $x$)) 
  RETURN()
  SEP (csr_rep $\pi_1$ $A$ m;
       data_at $\pi_2$ (tarray tdouble (Zlength $x$)) 
				(map Vfloat $x$) v; 
       data_at $\pi_3$ (tarray tdouble (matrix_rows $A$)) 
				(map Vfloat $y$) p).
\end{lstlisting}

The  \lstinline{WITH} in the CSR specification \lstinline{csr_mv_spec} quantifies over 8 logical variables that appear in both the precondition and the postcondition.
The variable $A$ is the formal model of the floating-point matrix, and $x$ is the model of the vector.
Pointer value $m$ is the address of a CSR representation of
$A$, and $v$ is the address of the array containing values $x$.
$\pi_1,\pi_2$ are permission-shares
for read access to $A$ and $x$, and $\pi_3$ specifies write
permission for address $p$ where the output vector $y$ is to be
stored.

The precondition \lstinline{PRE} in \lstinline{csr_mv_spec} asserts that,
  given 3 parameters whose
C-language types are (respectively) pointer-to-struct,
pointer-to-double,
pointer-to-double;
\begin{itemize}
\item \lstinline{PROP}: the input arrays
  are readable and the output array is writable;
every row of the matrix has the same length as vector
$x$; the dimensions of $A$ and $x$ are representable as C
integers; all the values in $A$ and $x$ are finite;
\item \lstinline{PARAMS}:  the values of the function
parameters are the values $m,v$, and $p$, respectively; and
\item \lstinline{SEP}: the data structures in memory represent $A$ at address $m$,
  and $x$ at address $v$,
and address $p$ has an uninitialized array (to hold the
result).\end{itemize}
In writing the precondition, we use an \emph{abstract data
type} representation relation \lstinline{csr_rep}
to describe the data stored at address $m$.

The postcondition \lstinline{POST} asserts the following:  
there exists a float-vector $y$
that is \emph{equivalent} to the 
floating-point product $Ax$;
this result is stored at address $p$;
and the data at $m$ and $v$ is
undisturbed.  Furthermore, VST's program logic guaratees that any data not mentioned in the \lstinline{SEP} clauses remains undisturbed.

The user-defined \emph{representation relation}
\lstinline{csr_rep $A$ $m$} says that matrix $A$ is
represented as a data structure at address $m$.
In turn it relies on a \emph{functional model} of 
sparse matrices.  We define this functional model at any
floating-point type $t$ (single-precision, double-precision,
half, quad, etc.). We prove lemmas in Coq about the
representation relation, and use those to prove in VST (embedded in Coq)
that the C function satisfies the
\lstinline{csr_mv_spec}.


  
  
