\section{Conclusion}\label{sec:conclusion} The LAProof library provides a
promising modular \emph{proof layer} between the verification of application
software and the verification of programs implementing linear algebra operations
defined by the BLAS standard. The formal roundoff error analyses provided
 by LAProof carefully handle underflow and overflow, and capture all
higher-order error terms. We have demonstrated a practical case study of how
LAProof can be used as such an interface by connecting the LAProof
implementation of matrix-vector product and its formally 
guaranteed error bound to a C program implementing sparse matrix-vector
multiplication using the compressed sparse row format.

A natural question arises concerning the ease of using the LAProof library in
verification efforts other than the sparse matrix-vector multiplication example
we have described. We believe that we have made at least two design choices that
will support the porting of LAProof to other verification efforts.

Firstly, rather than using the Mathematical Components Library~\cite{mathcomp}
directly to define our functional models in Coq, we chose to implement our
functional models using Coq's standard lists over arbitrary types. This ensures
that LAProof is a middle ground between the verification of programs using tools
like VST, which tend to use concrete Coq types, and the abstract and dependent
types used by the MathComp library, which are more useful when proving abstract
properties of programs. Our proofs of correctness of the LAProof operations with
respect to MathComp operations over matrices and vectors allows clients of
LAProof to lift the error bounds derived from the LAProof functional models over
Coq lists to theorems that use MathComp.

Secondly, mixed backward-forward error bounds separate rounding errors from the
stability of the mathematical problem being solved by the application software
more clearly than forward error bounds. The roundoff error analyses provided by
LAProof should therefore be more widely usable than forward error bounds alone.

A limitation of providing mixed backward-forward error bounds to clients of
LAProof is automation. Forward error analysis requires successively accumulating
the error introduced by each floating-point operation, while backward error
analysis produces bounds of the form of equation (\ref{eq:BE}), which requires
identifying the error terms generated by each operation that can be propagated
back onto the operands. In comparison to forward error, automated backward error
analysis for numerical software has received limited treatment in the literature~\cite{BEA}.

We conclude by noting that while the roundoff error analyses in LAProof are
performed for particular implementations in Coq, the formal statement of LAProof
theorems can serve as an interface to which other implementations can be shown
to adhere. It is our hope that LAProof can therefore serve as a proof interface
with a reference implementation -- in the spirit of BLAS -- in the formal
verification of numerical programs.

