\section{Functional Models} % for Basic Linear Algebra Operations}
\label{sec:models}
LAProof operations are pure functional programs written in Gallina, the functional programming
language embedded in Coq; we refer to these programs as 
\emph{functional models}. These operations are Coq functions 
over Coq lists (or lists of lists) of either Coq's axiomatic 
real numbers or a type \lstinline{ftype t}, which denotes IEEE 
754 compliant binary floating-point formats with the precision 
and maximum exponent supplied by the argument \lstinline{t}. 
The \lstinline{ftype} function is provided by the VCFloat 
package~\cite{vcfloat1,vcfloat2}, and is a user-friendly 
wrapper around the Flocq formalization of IEEE binary 
floating-point formats. We begin our description of the 
LAProof functional models by first introducing the low-level Coq 
definitions of matrices and vectors upon which they depend.

\subsection{Matrices and vectors}
Matrices and vectors in LAProof are defined using Coq lists over an arbitrary element type \lstinline{T}. 
% 
\begin{lstlisting}
Definition matrix (T : Type) := list (list T).
Definition vector (T : Type) := list T.
 \end{lstlisting} \vspace{-1em}
%
For example, a vector of double-precision floats in LAProof would have type \lstinline{vector (ftype Tdouble)}. Henceforth, we will use the notation of $\mathbb{F}^n_{p,e}$ and \lstinline{vector (ftype t)} interchangeably, and similarly for matrices. The LAProof library is developed under the assumption that matrices are in row-major form. 

\subsection{Vector operations}
The fundamental operation in the LAProof library is the inner (dot) product.  In order to define real-valued and floating-point valued functional models for the inner product, it suffices to define a generic polymorphic function \lstinline{DOT} over an arbitrary implicit type \lstinline{T}. \lstinline{DOT} takes two vectors $u$ and $v$ with elements are of type \lstinline{T}, and the functions \lstinline{add} and \lstinline{mul}, and produces a result of type \lstinline{T}.
%
 \begin{lstlisting}
Variables add mul : T $\rightarrow$ T $\rightarrow$ T. 
Variables u v : vector T. 

Definition DOT : T := 
fold$\_$left add (map (uncurry mul) (combine u v)).
 \end{lstlisting}
%
We define a floating-point functional model \lstinline{DOTF} by supplying \lstinline{DOT} with a generic \lstinline{ftype t } type and the appropriate functions over this type; LAProof uses the VCFloat functions 
\lstinline{BPLUS} and \lstinline{BMULT} over \lstinline{ftype t}. These VCFloat functions are simply wrappers around the corresponding IEEE operators defined in Flocq, so LAProof inherits the soundness of these operators with respect to the IEEE specification formalized by Flocq. A real-valued functional model  \lstinline{DOTR} is similarly defined with the addition and multiplication operations supplied by Coq's theory of axiomatic reals. Using these functional models, the mixed backward-forward error bound given in Theorem \ref{thm:bfDOT} is stated in Coq as follows.

\begin{lstlisting}
Variable t : type.
Variables u v: vector (ftype t).
Hypothesis Hfin:  is_finite (DOTF u v) = true.
Let n := (length v).

Theorem bfDOT: $\exists$ ($u'$ : list R) ($\eta$ : R),
  FT2R (DOTF $u$ $v$) = DOTR $u'$ (map FT2R $v$) + $\eta$ 
  $\wedge$ ($\forall$ $i$, ($i$ < n) $\rightarrow \exists \ \delta$, $u'_i$  = (1 + $\delta$) FT2R ($v_i$)
  $\wedge$  $|\delta| \le   h(n)$ )  $\wedge$ $|\eta| \le g(n,n)$),
\end{lstlisting}
where the function \lstinline{FT2R : ftype t $\rightarrow 
\mathbb{R}$} is an injection from the floating-point values of 
type \lstinline{ftype t} to real values.

Floating-point and real-valued functional models for the remaining vector operations of addition,  summation,  and scaling by a constant are defined from the following polymorphic functions over a generic element type \lstinline{T}:
%
\begin{lstlisting}
Variables add mul : T $\rightarrow$ T $\rightarrow$ T. 

Definition VecAdd (u v :  vector T): vector T
     := map (uncurry add) (combine u v).

Definition SUM: vector T $\rightarrow$ T
     := fold$\_$right add. 
  
Definition sVec  (a: T) : vector T $\rightarrow$ vector T
     := map (mul a).
 \end{lstlisting} \vspace{-1em}
%

\subsection{Matrix-vector operations}
The core matrix vector operation implemented in LAProof is the matrix-vector product. We denote the floating-point and real-valued functional models for matrix-vector  multiplication implemented by LAProof as  \lstinline{MVF} and  \lstinline{MVR}, respectively. These functions are built by supplying the previously defined inner products (\lstinline{DOTR} and \lstinline{DOTF}) to a polymorphic function \lstinline{MV} defined over an arbitrary implicit element type \lstinline{T}:
\begin{lstlisting}
Variable dot : vector T $\rightarrow$ vector T $\rightarrow$ T. 
Variables (A : matrix T) (v : vector T).

Definition MV : vector T
        := map (fun a $\Rightarrow$ dot a v) A.
 \end{lstlisting}

A formal statement of the mixed backward-forward error bound for matrix-vector multiplication given in Theorem \ref{thm:bfMV} requires defining suitable functional models for matrix addition. 

\subsection{Matrix operations}
Functional models for floating-point and real-valued matrix addition and scaling by a constant are defined in LAProof from the following polymorphic functions. 
\begin{lstlisting}
Definition map2 {A B C: Type}(f:A$\rightarrow$B$\rightarrow$C)(x:A)(y:B)
    := map (uncurry f) (combine x y).
 \end{lstlisting}

\begin{lstlisting}
Definition sMat {T: Type} (mul: T$\rightarrow$T$\rightarrow$T) (a: T)
    := map (map (mul a)) .
\end{lstlisting}

\begin{lstlisting}
Definition MatAdd {T: Type} (sum: T$\rightarrow$ T$\rightarrow$T)
    := map2 (map2 add). 
\end{lstlisting}
 
 Denoting real-valued \lstinline{MatAdd} and real-valued \lstinline{VecAdd} as $+_m$ and $+_v$,  respectively,  and floating-point valued and real-valued \lstinline{MV} as $\otimes_v$ and $*_v$,  respectively,  the formal LAProof statement of Theorem \ref{thm:bfMV} is given as follows. 

\begin{lstlisting}
Variable (A : matrix (ftype t)).
Variable (v : vector (ftype t)).
Let m := (length A).
Let n := (length v).
Notation Ar := (map (map FT2R) A).
Notation vr := (map FT2R v).
Hypothesis Hfin : is$\_$finite$\_$vec (MVF A v).
Hypothesis Hlen : $\forall$ x, In x A $\rightarrow$ length x = n.

Theorem bfMV: $\exists$ (E : matrix R) ($\eta$ : vector R),
  map FT2R (A $\otimes_v$ v) =  (Ar $+_m$ E) $*_v$ vr $+_v$ $\eta$ 
  $\wedge$ ($\forall \ i j, (i < m) \rightarrow (j < n) \rightarrow |E_{i,j} | \le h(n) |Ar_{i,j}| $
  $\wedge$ ($\forall$ k, In k $\eta \rightarrow$ |k| $\le g(n,n)$) 
  $\wedge$ eq$\_$size E A  $\wedge$ length $\eta$ = m.
 \end{lstlisting}
 
 Finally, the real-valed and floating-point functional models for the matrix-matrix product are defined using the following polymorphic function, \lstinline{MM}, which utilizes the matrix-vector product.
\begin{lstlisting}
Variable dot : vector T $\rightarrow$ vector T $\rightarrow$ T. 
Variables (A B : matrix T).

Definition MM : matrix T 
     := map (fun b $\Rightarrow$ MV dot A b) B.
 \end{lstlisting}
 
 \subsection{Extension to MathComp}
 
 The correctness of the basic linear algebra operations defined 
 above is supported by formal proofs connecting the real-valued 
 operations \lstinline{VecAdd}, \lstinline{DOT}, 
 \lstinline{MV}, \lstinline{MatAdd}, and \lstinline{MM} to 
 their counterparts in the Mathematical Components (MathComp) 
 Library~\cite{mathcomp}. We use the mappings from Coq lists to 
 MathComp matrices and vectors over the reals from Cohen et. 
 al~\cite{cohen2022} to prove that there is an injection from 
 the LAProof functional models for these core operations to 
 their corresponding MathComp operations. This 
 mapping is particularly useful in two cases. Firstly,  
 composing LAProof mixed backward-forward error bounds for 
 matrix-matrix operations requires utilizing the ring 
 properties of matrices, and MathComp provides extensive 
 support for automatic rewriting over ring and field 
 structures. Secondly, the big operators~\cite{bigops} in 
 MathComp enable intuitive definitions of induced norms for 
 normwise forward error bounds, which can be derived from our 
 mixed backward-forward error bounds. Our proofs of correctness 
 of the LAProof operations with respect to the MathComp 
 operations allows clients of LAProof to lift the error bounds 
 derived from the 
 functional models over Coq lists to theorems over MathComp 
 matrices and vectors. 

In the following section, we illustrate how the floating-point functional models  for the basic linear algebra operations introduced here can be connected to concrete C implementations, thereby guaranteeing the accuracy of practically useful programs.
